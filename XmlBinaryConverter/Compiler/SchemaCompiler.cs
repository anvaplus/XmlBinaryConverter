using System;
using System.Collections.Generic;
using System.IO;
using System.Xml;
using System.Xml.Schema;
using XmlBinaryConverter.Interfaces;
using XmlBinaryConverter.XmlTools;

namespace XmlBinaryConverter.Compiler
{
	public class SchemaCompiler : ISchemaCompiler
	{
		private readonly XmlInfo _xmlInfo = XmlInfo.GetInstance;
		private XmlSchema _schema;
		private Compiler _compiler;

		/// <param name="xsdSchemaFilePath"></param>
		public SchemaCompiler(string xsdSchemaFilePath)
		{
			// The Read method will throw errors encountered on parsing the schema
			StreamReader reader = new StreamReader(xsdSchemaFilePath);
			Build(reader);
		}

		public SchemaCompiler(StreamReader reader)
		{
			Build(reader);
		}

		private void Build(StreamReader reader)
		{
			_schema = XmlSchema.Read(reader, StrictValidationCallback);
			_compiler = new Compiler(_schema);
		}

		void StrictValidationCallback(object sender, ValidationEventArgs e)
		{
			Console.WriteLine("Invalid XSD schema");
			throw new XmlBinaryConverterException(e.Message);
		}

		public List<string> GetHeaderFile()
		{
			List<string> result = new List<string>();

			result.Add($"//! Starting offset map creation @ {DateTime.Now}");
			result.Add("//! Do _not_ do any modifications on this file. This file is auto-generated by XmlBinaryConverter, every change will be overwritten.");
			result.Add("");
			result.Add("#include <stdint.h>");
			result.Add("#include <assert.h>");
			result.Add("#include <stddef.h>");
			result.Add("");
			result.Add("#ifndef XmlBinaryConverter_STRUCTURE_H");
			result.Add("#define XmlBinaryConverter_STRUCTURE_H");
			result.Add("");
			result.AddRange(_compiler.Info.CDefinition);
			result.Add("");
			result.Add("#endif //XmlBinaryConverter_STRUCTURE_H");
			result.Add("");
			result.Add($"//! Total number of bytes {_compiler.Info.GetBinarySize()}");
			result.Add($"//! Ending offset map creation for version {DateTime.Now}");

			return result;
		}

		List<ValidationEventArgs> _eventArgs;

		public List<ValidationEventArgs> ValidateXml(XmlDocument xmlDoc)
		{
			lock (this)
			{
				// Create the XmlReader object.
				XmlSchemaSet schemas = new XmlSchemaSet();
				schemas.Add(_schema);
				xmlDoc.Schemas = schemas;

				_eventArgs = new List<ValidationEventArgs>();
				xmlDoc.Validate(PermissiveValidationCallback);

				return _eventArgs;
			}
		}

		private void PermissiveValidationCallback(object sender, ValidationEventArgs e)
		{
			_eventArgs.Add(e);
		}

		public byte[] Compile(XmlDocument xmlDoc)
		{
			XmlNamespaceManager nsManager = ExtendNamespaceManager(xmlDoc);

			return _compiler.Info.GetBytes("", xmlDoc, nsManager);
		}

		public XmlDocument Decompile(byte[] data)
		{
			// Create an XmlNamespaceManager to resolve the default namespace.

			XmlDocument xmlDoc = new XmlDocument();
			XmlNamespaceManager nsManager = new XmlNamespaceManager(xmlDoc.NameTable);
			nsManager.AddNamespace(_xmlInfo.GetXmlNamespacePrefix(), xmlDoc.DocumentElement.NamespaceURI);

			// WARNING! Decompiled blobs are not guaranteed to be valid according to the schema.
			// WARNING! Empty elements sometimes (depending on the XSD) may not be reconstructed correctly.
			// WARNING! Nonetheless they can be deserialized successfully.
			_compiler.Info.FromBytes("", xmlDoc, nsManager, data);

			return xmlDoc;
		}

		public XmlNamespaceManager ExtendNamespaceManager(XmlDocument xmlDoc)
		{
			XmlNamespaceManager nsManager = new XmlNamespaceManager(xmlDoc.NameTable);
			nsManager.AddNamespace(_xmlInfo.GetXmlNamespacePrefix(), xmlDoc.DocumentElement.NamespaceURI);
			return nsManager;
		}
	}
}
